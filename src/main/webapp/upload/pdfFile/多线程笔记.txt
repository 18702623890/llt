一.线程概念
二.线程如何创建
三.线程状态切换(生命周期),线程调度方法(join,sleep,yield,start,stop)
四.线程同步
五.线程通讯
六.安全的线程容器
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
程序：为了解决某些问题或业务而编写的有序指令（代码）的集合
进程：程序的一次执行操作，属于系统级别，使用系统的资源（CPU,内存...）,非常的消耗系统资源
线程：是进程中的一个小的执行单元(子程序)，共享进程资源，并且独立并行运行

例如：一个eclipse进程启动，系统分配了200M内存,然后在eclipse中启动了10个执行main(),这10个执行的main()就是该进程中的10个线程，共享了进程中的资源（CPU和内存）

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
如何启动或创建线程？
1.MyThread继承Thread,重写run(),通过调用MyThread类对象的start()启动线程
		MyThread myThread1 = new MyThread();
		myThread1.setName("亮亮线程");
		//启动线程
		myThread1.start();
2.MyThread实现接口,重写run(), 创建线程类对象Thread thread =new Thread(自定义类MyThread,"线程名称");通过thread对象的start()启动线程
		MyThread1 myThread1 = new MyThread1();		
		Thread thread1 = new Thread(myThread1, 线程名称);
		thread1.start();
		
备注：推荐使用实现接口方式，因为当一个类已经继承了其他类时，不能再继承线程类，无法完成多线程开发，而java中接口是可以被多实现的

直接执行run()和直接执行start()是不一样的！！
直接执行run（）并不会启动多线程，只是象以前代码一样逐行执行，只有执行start()才能进入多线程的并行执行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
常用方法：
start()启动线程,
setName()设置线程名称,
getName()获取线程名称,
currentThread()获取当前运行的线程对象，
getContextClassLoader()获得当前线程的上下文对象

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
线程状态切换(生命周期)
1.新生态-->new创建出来的线程对象
2.可运行状态-->执行了start()方法后的线程处于可运行状态
3.运行状态-->当处于可运行状态的线程，通过系统调度，分配时间片，进入运行状态
yield():线程礼让,让比自己线程级别高或相等的线程有优先执行的权利，但是本线程仍然会继续执行
4.阻塞状态：
sleep:线程进入睡眠，睡眠时间结束，继续运行
io:断点调试，等待键盘输入，造成线程无法直接运行结束，必须断点结束或键盘输入完成才继续执行
join:A线程插入（合并）到B线程,必须等待A线程执行完成，才会执行B线程
5.死亡状态：当正在运行的线程已经运行结束或中途中断运行，则线程进入死亡状态
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
线程的优先级Priority：级别从1~10，数字越大级别越高，代表优先执行的概率越高，但是不代表一定会先执行,所有线程的默认优先级是5

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
完成4个售票点同时进行销售100张票，打印个售票点售出的票号
线程并发：当一个线程在访问某个资源时，原本获取到的数据被其他线程给篡改了，导致数据不正确,那么这就是多线程的线程并发

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
如何保证多线程访问资源的安全性--》使用线程同步

使用关键字:synchronized保证线程同步，是的多个线程同时访问一个共享资源时，每次只能有一个线程A访问,共享资源将被锁住，其他线程等到之前的线程访问结束，释放开该同步锁，其他线程拥有相同的优先权限去访问释放开的共享资源，之前的访问线程A也同样具备相同机会再次访问共享资源获得同步锁

线程同步实现的两种方式：(两种的区别在于锁定的范围大小不同)
锁方法:在方法上加上synchronized，锁住方法
public synchronized void run() {
}

锁对象:使用代码块，锁住访问对象
synchronized (obj) {
	//在这个范围之内obj对象将被加锁
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
五.线程通讯
这些通讯的方法都是对象的方法

wait():线程执行了wait()时，将进入等待队列,同时会将同步锁释放，等待其他线程执行notify()或notifyAll()进行唤醒
notify():随机唤醒等待队列中的一个线程
notifyAll():唤醒等待队列中所有的线程






